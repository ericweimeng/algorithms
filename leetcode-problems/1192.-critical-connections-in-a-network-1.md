---
description: 'Hard, Graph, DFS'
---

# 1192. Critical Connections in a Network

> There are `n` servers numbered from `0` to `n-1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [a, b]` represents a connection between servers `a` and `b`. Any server can reach any other server directly or indirectly through the network.
>
> A _critical connection_ is a connection that, if removed, will make some server unable to reach some other server.
>
> Return all critical connections in the network in any order.
>
> **Example 1:**
>
> ![](https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png)
>
> ```text
> Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
> Output: [[1,3]]
> Explanation: [[3,1]] is also accepted.
> ```
>
> **Constraints:**
>
> * `1 <= n <= 10^5`
> * `n-1 <= connections.length <= 10^5`
> * `connections[i][0] != connections[i][1]`
> * There are no repeated connections.

## Solutions

### Approach \#1, DFS

If a connection is critical means this connection must not be in a circle. Or to put it differently, for one node on one side of the critical connection, it can only be access from the other side of the node. Therefore, following this theory, if all following nodes of a node all have ranks 1 greater than the rank of the current node, then the current node with its previous node DFS to this node form the critical connection.

```python
import collections
class Solution(object):
    def criticalConnections(self, n, connections):
        def dfs(rank, cur, prev):
            low_rank[cur], res = rank, []
            for nei in graph[cur]:
                if nei == prev:
                    continue
                if not low_rank[nei]:
                    res += dfs(rank + 1, nei, cur)
                low_rank[cur] = min(low_rank[cur], low_rank[nei])
                if low_rank[nei] >= rank + 1:
                    res.append([cur, nei])
            return res
        low_rank, graph = [0] * n, collections.defaultdict(list)
        for p, n in connections:
            graph[p].append(n)
            graph[n].append(p)            
        return dfs(1, 0, -1)
```

```python
class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        
        graph = collections.defaultdict(set)
        
        for u, v in connections:
            graph[u].add(v)
            graph[v].add(u)
            
        jumps = [-1] * n
        
        res = []
        
        self.dfs(graph, 0, -1, 0, jumps, res)
        
        return res
        
    def dfs(self, graph, cur, parent, level, jumps, res):
        
        jumps[cur] = level + 1
        
        for nei in graph[cur]:
            if nei == parent:
                continue
            elif jumps[nei] == -1:
                jumps[cur] = min(jumps[cur], self.dfs(graph, nei, cur, level + 1, jumps, res))
            else:
                jumps[cur] = min(jumps[cur], jumps[nei])
            
        if jumps[cur] == level + 1 and cur != 0:
            res.append([parent, cur])
        
        return jumps[cur]
```

## Variations

node number starts with 1

```python
import collections

def criticalConnections(n, connections):

    if not n or not connections or not connections[0]:
        return []
        
    graph = collections.defaultdict(set)
    
    for u, v in connections:
        graph[u].add(v)
        graph[v].add(u)
        
    jumps = collections.defaultdict(int)
    
    res = []
    
    dfs(graph, 1, 0, 0, jumps, res)
    
    return res
    
def dfs(graph, cur, parent, level, jumps, res):
    
    jumps[cur] = level + 1
    
    for nei in graph[cur]:
        if nei == parent:
            continue
        elif jumps[nei] == 0:
            jumps[cur] = min(jumps[cur], dfs(graph, nei, cur, level + 1, jumps, res))
        else:
            jumps[cur] = min(jumps[cur], jumps[nei])
        
    if jumps[cur] == level + 1 and cur != 1:
        res.append([parent, cur])
    
    return jumps[cur]

n = 0
edges = []

print(criticalConnections(n, edges))
```

