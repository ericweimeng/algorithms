---
description: 'Hard, Graph, DFS'
---

# 1192. Critical Connections in a Network

> There are `n` servers numbered from `0` to `n-1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [a, b]` represents a connection between servers `a` and `b`. Any server can reach any other server directly or indirectly through the network.
>
> A _critical connection_ is a connection that, if removed, will make some server unable to reach some other server.
>
> Return all critical connections in the network in any order.
>
> **Example 1:**
>
> ![](https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png)
>
> ```text
> Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]
> Output: [[1,3]]
> Explanation: [[3,1]] is also accepted.
> ```
>
> **Constraints:**
>
> * `1 <= n <= 10^5`
> * `n-1 <= connections.length <= 10^5`
> * `connections[i][0] != connections[i][1]`
> * There are no repeated connections.

## Solutions

### Approach \#1, DFS

If a connection is critical means this connection must not be in a circle. Or to put it differently, for one node on one side of the critical connection, it can only be access from the other side of the node. Therefore, following this theory, if all following nodes of a node all have ranks 1 greater than the rank of the current node, then the current node with its previous node DFS to this node form the critical connection.

```python
import collections
class Solution(object):
    def criticalConnections(self, n, connections):
        def dfs(rank, cur, prev):
            low_rank[cur], res = rank, []
            for nei in graph[cur]:
                if nei == prev:
                    continue
                if not low_rank[nei]:
                    res += dfs(rank + 1, nei, cur)
                low_rank[cur] = min(low_rank[cur], low_rank[nei])
                if low_rank[nei] >= rank + 1:
                    res.append([cur, nei])
            return res
        low_rank, graph = [0] * n, collections.defaultdict(list)
        for p, n in connections:
            graph[p].append(n)
            graph[n].append(p)            
        return dfs(1, 0, -1)
```

```python
class Solution:
    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:
        
        graph = collections.defaultdict(set)
        
        for u, v in connections:
            graph[u].add(v)
            graph[v].add(u)
            
        jumps = [-1] * n
        
        res = []
        
        self.dfs(graph, 0, -1, 0, jumps, res)
        
        return res
        
    def dfs(self, graph, cur, parent, level, jumps, res):
        
        jumps[cur] = level + 1
        
        for nei in graph[cur]:
            if nei == parent:
                continue
            elif jumps[nei] == -1:
                jumps[cur] = min(jumps[cur], self.dfs(graph, nei, cur, level + 1, jumps, res))
            else:
                jumps[cur] = min(jumps[cur], jumps[nei])
            
        if jumps[cur] == level + 1 and cur != 0:
            res.append([parent, cur])
        
        return jumps[cur]
```

## Variations

{% embed url="https://leetcode.com/discuss/interview-question/436073/" %}

The idea to approach this problem is since we are looking for a critical node that without it, the graph would be disconnected, we can actually start looking at nodes that deleting it would not create disconnection graph. If a node is not a critical connection, then during a traverse, it would be reached for more than once, then if we do DFS traverse of the graph and keep the level of depth, every time we go into the next node we increase the level by one. When it reaches a node that has been visited before, we update the minimum level for that node, and in the end we check if the minimum level for current node is equal to the level + 1, meaning all its nodes visited in the subsequent DFS traverse did not reach to its parent, then it's in a critical connection. We define V is the number of nodes in the graph, E is the number of edges. Time Complexity: O\(V + E\) since we visit each edges to create graph and visit each node only once. Space: O\(V\)

node number starts with 1

```python
import collections

def criticalConnections(n, connections):

    if not n or not connections or not connections[0]:
        return []
        
    graph = collections.defaultdict(set)
    
    for u, v in connections:
        graph[u].add(v)
        graph[v].add(u)
        
    jumps = collections.defaultdict(int)
    
    res = []
    
    dfs(graph, 1, 0, 0, jumps, res)
    
    return res
    
def dfs(graph, cur, parent, level, jumps, res):
    
    jumps[cur] = level + 1
    
    for nei in graph[cur]:
        if nei == parent:
            continue
        elif jumps[nei] == 0:
            jumps[cur] = min(jumps[cur], dfs(graph, nei, cur, level + 1, jumps, res))
        else:
            jumps[cur] = min(jumps[cur], jumps[nei])
        
    if jumps[cur] == level + 1 and cur != 1:
        res.append([parent, cur])
    
    return jumps[cur]

n = 0
edges = []

print(criticalConnections(n, edges))
```

return list of critical nodes

```python
import collections

def criticalConnections(n, numEdges, connections):

    if not n or not connections or not connections[0]:
        return []
        
    graph = collections.defaultdict(set)
    
    for u, v in connections:
        graph[u].add(v)
        graph[v].add(u)
        
    jumps = collections.defaultdict(int)
    
    res = set()
    
    dfs(graph, 1, 0, 0, jumps, res)
    
    return list(res)
    
def dfs(graph, cur, parent, level, jumps, res):
    
    jumps[cur] = level + 1
    
    for nei in graph[cur]:
        if nei == parent:
            continue
        elif jumps[nei] == 0:
            jumps[cur] = min(jumps[cur], dfs(graph, nei, cur, level + 1, jumps, res))
        else:
            jumps[cur] = min(jumps[cur], jumps[nei])
        
    if jumps[cur] == level + 1 and cur != 1:
        res.add(parent)
    
    return jumps[cur]

numNodes = 8
numEdges = 8
edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4], [5, 7], [2,4]]

print(criticalConnections(numNodes, numEdges, edges))
```

In case

```python
def isConnected(graph):
    trav = set()
    start = None
    for k in graph:
        start = k 
        break
    
    def DFS(node):
        trav.add(node)
        
        for child in graph[node]:
            if child not in trav:
                DFS(child)
        return
    
    DFS(start)
    if len(trav)==len(graph):
        return True
    return False
    
                
def getGraph(nodeNum, edges):
    g = {}
    for n in range(nodeNum):
        g[n] = []
    
    for edg in edges:
        g[edg[0]].append(edg[1])
        g[edg[1]].append(edg[0])
    
    return g

    
    
    
def findCriticalNodes(nodeNum, edges):

    ans = []
    for n in range(nodeNum):
        g = getGraph(nodeNum, edges)
        del g[n]
        for node in g:
            if n in g[node]:
                g[node].remove(n)
     
        if(not isConnected(g)):
            ans.append(n)
        
 
    return ans

print(findCriticalNodes(7, [[0,1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3,4]]))
```

