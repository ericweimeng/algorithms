---
description: 'Easy, DFS, Tree'
---

# 993. Cousins in Binary Tree

> In a binary tree, the root node is at depth `0`, and children of each depth `k` node are at depth `k+1`.
>
> Two nodes of a binary tree are _cousins_ if they have the same depth, but have **different parents**.
>
> We are given the `root` of a binary tree with unique values, and the values `x` and `y` of two different nodes in the tree.
>
> Return `true` if and only if the nodes corresponding to the values `x` and `y` are cousins.
>
> **Example 1:**  
> ![](https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png)
>
> ```text
> Input: root = [1,2,3,4], x = 4, y = 3
> Output: false
> ```
>
> **Example 2:**  
> ![](https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png)
>
> ```text
> Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
> Output: true
> ```
>
> **Example 3:**
>
> ![](https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png)
>
> ```text
> Input: root = [1,2,3,null,4], x = 2, y = 3
> Output: false
> ```
>
> **Constraints:**
>
> * The number of nodes in the tree will be between `2` and `100`.
> * Each node has a unique integer value from `1` to `100`.

## Solutions

### Approach \#1

```python
class Solution:
    def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
        left = self.find_comp_info(root, x, None, 0)
        right = self.find_comp_info(root, y, None, 0)
        return left and right and left[1] and right[1] and left[1] != right[1] and left[0] == right[0]
        
    def find_comp_info(self, root, val, parent, depth):
        if not root:
            return (-1, None)
        
        if root.val == val:
            return (depth, parent)
        
        left = self.find_comp_info(root.left, val, root, depth + 1)
        right = self.find_comp_info(root.right, val, root, depth + 1)
        
        # need to keep returning depth and parent info all the way to
        # the top
        if left and left[1]:
            return left
        elif right and right[1]:
            return right
```

