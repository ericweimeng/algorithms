---
description: 'Medium, DP'
---

# 300. Longest Increasing Subsequence

> Given an unsorted array of integers, find the length of longest increasing subsequence.

**Example:**

```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```

**Note:**

* There may be more than one LIS combination, it is only necessary for you to return the length.
* Your algorithm should run in O\(n2\) complexity.

**Follow up:** Could you improve it to O\(n log n\) time complexity?

## Approach \#1 DP

```
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        
        dp = [1 for _ in range(n)]
        res = 0
        for i in range(n):
            # dp[i] = 1
            j = 0
            # 这里注意, dp[i] 表示的是以nums[i]结尾的元素的最长子序列的长度, 只要后面的数字比这个结尾的元素大，那必将
            # 这个dp[i]子序列里的所有数字都大
            for j in range(i):
                # 每次比较的是i位的元素和这位之前的所有元素，从而找出以j位结尾的子序列
                if nums[j] < nums[i]:
                    # 一旦找到一个j位的元素小于i位，意味着这个为元素可以成为以j位结尾的子最大上升序列的新的最后一位
                    # 所以max查找的其中dp[j] + 1 是在说以j结尾的最大子上升序列加上i这位新的元素的长度, 即dp[j] + 1
                    # 比较dp[i]是因为每次对比过后会更新dp[i]，所以可能这层对比的dp[i] 是上一层更新过非1的最长值
                    dp[i] = max(dp[i], dp[j] + 1)
            
            # 每次找完以i结尾的新最长子序列的最长值后更新一下最终结果
            res = max(res, dp[i])
                    
                
        return res
```

